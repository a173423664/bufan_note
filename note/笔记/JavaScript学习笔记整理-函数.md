## javascript学习笔记整理 :函数
+ 函数就是一段可以反复调用的代码块
+ 函数使用function关键字来定义.还包括一个称为形参的(parameter)的标识符列表,这些参数在函数体内像变量一样工作.
+ 函数调用会为形参提供实参的值.函数使用它们实参值来计算返回值,称为该函数调用表达式的值.
+ 除了实参以外,每次调用还会拥有另一个值---本次调用的上下文---这就是this关键字的值.
+ 如果函数挂载在一个对象上,作为对象的一个属性,就称它为对象的方法.
+ javascript的函数可以嵌套在其他函数中定义,这样它们就可以访问它们被定义时所处的作用域中任何变量,这就是javascript的闭包.
  
+ 定义函数的三种方法
1.  function命令  function name
    - name是函数名称标识符,函数名称是函数声明语句必需的部分.不过杜宇函数表达式来说,名称是可选的,如果存在,该名字只存在于函数体内,并指向该函数对象本身.
    - 圆括号:圆括号内放置0个或多个用逗号隔开的标识符组成的列表,这些标识符就是函数的参数名称.
    - 花括号:可包含0条或多条javascript语句.这些语句构成了函数体.一旦调用就会执行这些语句.
2. 函数表达式
    - var f = function()
    - 采用函数表达式声明函数时,function命名后面不带有函数名.如果加上函数名,该函数名只在函数体内部有效,在函数体外部无效.
3. Function()



    - 函数定义还可以通过Function()构造函数来定义
    ```
    var f = new
    function('x','y','returen x+y');
    等价于
    var f = function(x,y){
        return x+y;
    }
    ```
    - 除了最后一个参数是函数体外,前面的其他的参数都是函数的形参.如果函数不包含任何参数,只须给构造函数简单的传入一个字符串---函数体---即可.不过Function()构造函数在实际编程中很难用到.
+ 注意点:
    - 如果同一个函数被多次定义(声明)后面的定义(声明)就会覆盖前面的定义(声明)
    - 函数可以调用自身,这就是递归.
    - 不能在条件语句中声明函数.

+ 函数命名
    - 任何合法的的javascript标识符都可以用作一个函数的名称.
    - 函数名称通常是动词或者以动词为前缀的词组.
    - 通常函数名的第一个字符为小写.
    - 当函数名包含多个单词时,可以采用下划线法,比如like_this();也可以采用驼峰法,也就是除了一个单词之外的单词首字母使用大写字母,比如likeThis();

3. 被提前
+ 就像变量的"被提前一样",函数声明语句也会"被提前"到外部脚本或外部函数作用域的顶部.所以以这种方式声明的函数,可以被在它定义之前出现的代码所调用.
+ 注意:
    - 以表达式定义的函数并没有"被提前".
    - 变量其实是分为声明,赋值两部分的,上面的代码等同于下面的形式
    ```
    f();
    var f = function(){};
    等同于:
    var f;
    f();
    f = function();
    调用的时候f只是被声明了,还没有被赋值,等于undefined,所以会报错.
    ```
4. 嵌套函数 
   - 在javascript中,函数可嵌套在其他函数里.

5. 函数的调用
+ 构成函数主体的javascript代码在定义时并不会执行,只有调用该函数,它们才会执行,有4中方法调用JavaScript函数.
    - 作为函数
    ```
    f();
    ```
    - 方法调用
    ```
    o.f = function(){}
    o.f();
    ```
    - 构造函数调用
      - 如果函数或者方法调用之前前面带有关键字new,它就构成构造函数调用.凡是没有形参的构造函数调用都可以省略圆括号.
    -  间接调用
6. 函数的实参与形参
   - 可选形参 当调用函数的时候传入的实参个数比函数声明时指定的形参个数要少,剩下的形参都将设置为undefined.为了保持好的适应性,一般应当给参数赋予一个合理的默认值.
    ```
    function go(x,y){
        x = x || 1;
        y = y || 2;
    }  
+ 注意:
    - 当用这中可选实参来实现函数时,需要将可选实参放在参数列表的最后一个.那些调用你的函数的程序员是没法省略第一个参数并传入第二个实参的.
    - 当调用函数时,传入的实参个数超过函数定义时的形参个数是,是没有办法直接获得未命名值得引用.
    - 这时,标识符arguments出现了,其指向实参对象的引用,实参对象是一个类数组对象,可以通过数字下标来访问传入函数的实参值,而不是非要通过名字来得到实参.
    ```
    function go(x){
        consolo.log(arguments[0]);
        consolo.log(arguments[1]);
        go(1,2);
    }
    ```
    - arguments有一个length属性,用以标识其包含元素的个数.
+ 注意:
    - arguments并不是一个真正的数组,它是一个实参对象.每个实参对象都包含以数字为索引的一组元素以及length属性.
    - 通过实参名字来修改实参值的话,通过arguments[]数组也可以获取到更改后的值
    ```
    function f(x){
        consloe.log(x); //1
        <!-- arguments[0] = null; -->
        <!-- console.log(x); //null -->
    }
    f(1);
    ```
    - 在上面例子中,arguments[0]与x指代同一个值,修改其中一个值会影响另一个值,注意:如果有同名参数,则取最后出现的那个值.

8. 作为值的函数
+ 在javascript中,我们可以将函数的值赋值给变量.
9. 函数作用域 
+ 作用域(scope)指的是变量存在的范围.JavaScript中指存在两种作用域:
    - 一种是全局作用域,变量在整个程序中一直存在,所有地方都可以读取.
    - 一种是函数作用域,变量只在函数内部存在.在函数外部声明的变量就是全局变量(global variable),它可以在函数内部读取.
      - 函数内部定义的变量,会在该作用域内覆盖同名全局变量.
+ 注意:
    - 对于var命令来说,局部变量只能在函数内部声明,在其他区块中声明,一律都是全局变量.
    函数的执行依赖于变量的作用域,这个作用域是在函数定义时所决定的,而不是在函数调用时决定.
10. 函数内部的变量提升
+ 与全局作用域一样,函数作用域内部也会产生"变量提升"现象.var命令声明的变量,不管在什么位置,变量声明都会提升至函数体的头部.
11. 函数属性,方法和构造函数
+ name属性
    - name属性返回紧随跟在function关键字之后的那个函数名
    ```
    function f(){}
    f.name //f;
    ```
+ length属性
    - 函数的length属性是只读属性,代表函数形参的数量,也就是在函数定义时给出的形参个数.
    ```
    function f(x,y){}
    f.length //2
    ```
+ prototype属性
    - 每一个函数都包含一个prototype属性,这个属性指向一个对象的引用,这个对象称做"原型对象"(prototype object).

12. 闭包
+ JavaScript的函数可以嵌套在其他函数中的定义,这样它们就可以访问它们被定义时所处的作用域中的任何变量,这就是函数的闭包.
+ 闭包作用
    - 一个是可以读取函数内部的变量,另一个就是就这些变量始终保持在内存中,即闭包可以使得它们诞生环境一直存在.
    ```function f(a){
        return function(){
            return a++;
        }
    }
    var c = f(1);
    console.log(c); //1
    console.log(c); //2
    console.log(c); //3
    ```
    - 闭包的另一个作用就是封装对象的私有属性,私有方法.



