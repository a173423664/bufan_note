```
var obj1 = {name:'tom'}
var obj2 =  obj1
<!-- var obj2 = {name:'tom'} -->
这样写和上面不一样,实际上是创建了两个对象,它们的值相同,但是地址值不同
obj1.name = 'jack'
console.log(obj2.name) //jack
```
+ N引用变量的指向同一个对象,通过一个变量修改对象内部的数据,其他对象看的是修改之后的数据.
+ 想要变量指向同一个变量,只要变量保存的内容是对象内存的同一个地址值
+ 将一个变量赋值给另一个变量,相当于拷贝右边变量内存的内容赋值给左边.

+ 两个引用变量指向同一个对象,当修改其中一个引用变量指向另一个对象.另一个引用变量依然指向前一个对象. 

```
var a = {age:12}
var b = a
a = {name:'BOB', age : 13}
b.age = 14;
console.log(b.age,a.name,a.age) //14 BOB 13

function fn2(obj){
    obj = {age:15}
}
fn2(a)
console.log(a.age); //15
```
+ 当修改引用变量a指向另一个对象.这时b依然还是指向前一个对象
1. 将a这个实参传入obj相当于将a的数据内容赋值给obj 此时obj和a都指向同一个对象
2. 然后紧接着执行函数体.在函数内部修改局部变量指向的对象.但是a还是不受影响依然是原来的对象.所以输出a.age的时候依然是原来的值.
3. 函数执行完以后,局部变量会自动释放,对象变成了垃圾对象. 在后面的某个时刻由垃圾回收器回收