## javascript执行上下文理解
>可以理解为当前代码的运行环境,代码的运行环境分为三种:
1. 全局级别的代码
2. 函数级别的代码
3. Eval的代码 - 在Eval函数函数体内运行的代码.

+ 注意一点: 作用域在函数创建时就已经确定了,而不是在函数调用时确定.这点特点重要.
+ 然后按照程序执行的顺序,一步步把各个上下文环境加上
1. 第一步首先在加载程序的时候,已经确定了全局的上下文环境,并随着程序的执行而对变量进行赋值
2. 函数的执行上下文是在调用函数后建立的,执行上下文第一个阶段(准备阶段)是在调用函数后,执行具体代码前进行,执行上下文的第二阶段是在执行具体代码时进行.

 [执行上下文](../img/执行上下文2.jpg)
3. 第二步,在程序执行到27行,调用fn(10),此时生成此次调用fn函数时的上下文环境,压栈,并将此上下文环境设置为激活状态
4. 第三步,执行到第23行,调用ba(100),生成此次调用的上下文环境,压栈,并设置为活动状态.
5. 第四部,执行完23行,bar(100)调用完成,bar(100)上下文环境被销毁,接着执行第24行,调用bar(200),则又生成bar(200)的上下文环境,压栈,设置为激活状态.
6. 执行完第24步,则bar(200)调用结束,其上下文环境被销毁.此时会回到fn(10)上下文环境,变为活动状态.
7. 执行完第27行代码,fn(10)执行完成,fn(10)上下文被销毁,全局上下文环境回到了活动状态.
+ 我们可以看出,作用域只是一个'区域',一个抽象的概念,其中没有变量.要通过作用域对应的执行上下文环境来获取相应的变量.同一个作用域下,不同的调用会产生不用的执行上下文环境,继而产生不同变量的值.

+ 所以,如果要查找一个作用域下某个变量的值,就需要找到这个作用域对应的执行上下文环境.在其中变量的值.

## 执行上下文堆栈
+ 在浏览器中,javascript引起的工作方式是单线程的,也就说,某一时刻只有唯一的一个事件是被激活处理的.其他事件被放入列中.等待处理
+ 具体的工作原理:
    - 在js代码文件被浏览器载入后,默认最先进入的是一个全局的执行上文.当在上下文中调用一个执行函数时.程序就会进入该被调用函数内,此时引擎就会为该函数创建一个新的上下文环境,并且将其压入到执行上下文堆栈的顶部.浏览器总是执行上下文对栈顶部的上下文.一旦执行完毕,该上下文环境就会被弹出.然后,进入其下的上下文执行代码.这样堆栈中的上下文就会被弹出.直到只剩下全局的上下文.


## 执行上下文的建立过程
+ 我们已经知道,每当调用一个函数时,一个新的执行上下文就会被创建出来,然而在js引擎内部,这个上下文创建的过程具体分为两个阶段:
    1. 建立阶段(发生在调用函数之后,在执行函数内部体具体代码之前)
    2. 建立变量,函数,参数对象.并给参数赋值.
    3. 建立作用域链
    4. 确定this值.
    5. 也就是说除了arguments,函数声明,以及参数被赋予的具体的值,其他变量值都是undefined

+ 代码执行阶段
    1. 变量赋值,执行其他代码.


## 局部变量作用域提升
+ 
```
(function() {
            console.log(typeof foo); // function pointer
            console.log(typeof bar); // undefined

            var foo = 'hello',
                bar = function() {
                    return 'world';
                };

            function foo() {
                return 'hello';
            }

        }());​
```
+ 问题一:为什么我们可以在声明foo变量以前就可以访问到foo呢？
+ 因为在上下文的建立阶段,显示处理参数声明,然后是函数声明,最后才是变量声明,
1. 在发现foo函数声明后,就会在variableObject下面建立一个foo属性,其值是一个指向函数的引用,当处理变量声明的时候,发现有var foo的声明,但是variableObject已经具有foo属性,所以函数声明会忽略后来的变量声明.
+ 问题二:为什么bar是undefined呢?
1. 因为bar是变量的声明,在建立阶段的时候,被赋予的默认的值是undefined,由于它只有在代码执行阶段才会被赋予具体的值.所以在调用typeof(bar)输出值的时候,输出undefined.

```
(function(){
    console.log(typeof foo); //function
    var foo；
    function foo(){}； 
    //因为在执行上下文的准备阶段中先找函数声明，后找变量声明，所以取前面的函数声明，忽略后面的同名的变量声明，即在fooExecutionContext里会生成一句：foo: pointer to function c()，即foo的属性值为指向函数c()的指针

    foo = "foo";  //执行上下文的执行阶段，会对变量进行赋值，会把foo的值赋为"foo"
    console.log(typeof foo); //string.对foo的string赋值会覆盖掉foo的原来的属性值，它原来的属性值为指向函数c()的指针，现在在fooExecutionContext里名为foo的属性为foo: "foo";
})();
```
```
function a(){

    alert(typeof foo);//undefined

    var foo=function(){

    };//同名的变量，只不过其中一个赋值为函数。按照在执行上下文的准备阶段中先找函数声明，后找变量声明，但两个都为变量，他俩优先级相同，js引擎默认取前面的声明，忽略后面的声明。故最终fooExecutionContext里会生成一句：foo: undefined。
    var foo="foo";

    alert(typeof foo);//string，因为执行上下文的执行阶段，会对变量进行赋值，这个就是按照代码的先后顺序执行了，所以typeof foo为string.
    };
 a();
```

+ 总的来说,在建立执行上下文阶段,声明不重要,重要的是执行阶段的赋值,不管建立阶段执行上下文阶段的时候一个属性声明是怎么样的.仍旧可以被的赋值成不同类型的值.这也就是为什么javascript是弱类型语言.

+ 在执行上下文第一阶段的准备阶段里变量的声明总结起来有三条:
    1. 函数形参在声明的时候已经指定其形参的值.
    2. 之前的函数声明会忽略之后再声明的同名声明,不是后来同名声明是函数声明还是变量声明.
    3. 普通的变量声明,不会覆盖之前的同名声明,会被忽略此次声明.