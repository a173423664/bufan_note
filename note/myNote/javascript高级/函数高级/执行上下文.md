
>为什么会存在函数名提升和变量名提升?
+ 就是执行上下文的预处理,在执行集体数据或者局部数据之前,对全集数据进行预处理,比如var 定义的全局变量==>undefined,添加为window的属性



>执行上下文
+ 代码分类(位置)
    - 全局代码
    - 函数(局部)代码
+ 全局执行上下文
    - 在执行全局代码前将window确定为全局执行上下文
    - 对全集数据进行预处理
        - var定义的全局变量==>undefined,添加为window的属性
        - function声明的全局函数,==>赋值(fun),添加为window的方法
        - this==>赋值(window)
    - 开始执行全局代码

+ 函数执行上下文
    - 在调用函数,准备执行函数体之前,创建对应的函数执行上下文对象.(存在于栈中,虚拟的).
    - 对局部数据进行预处理
        - 形参变量赋值为实参, ==>添加为执行上下文的属性.
        - arguments==>赋值(实参列表)==>添加为执行上下文的属性.
        - var定义的局部变量==>undefined,==>添加为执行上下文的属性.
        - function声明的函数==>赋值(fun)==>添加为执行上下文的方法.
        - this==>(赋值)调用函数的对象.
    - 调用函数(次数),window.导致产生执行上下文栈 (后进先出).

+ 在全局代码执行前,js引擎就会创建一个栈来管理所有的执行上下文对象(虚拟的).
+ 在全局执行上下文(window)创建后,将其添加到栈中.
+ 在当前函数执行完后,将栈顶的对象移出(出栈).
+ 当所有的代码执行完后,栈中只剩下window.