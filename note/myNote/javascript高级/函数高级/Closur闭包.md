+ class选择器选择到的相同标签.组成的是一个伪数组.在遍历的时候,每个执行循环都是重新执行一次.浪费内存.
+ 正确做法应该在外面先声明一个变量获取到伪数组的长度.再执行循环体.

+ 利用闭包也可以保存下标[闭包](../img/闭包-1.png)
+ 闭包的理解,当一个嵌套的内部(子)函数.引用了嵌套的外部(父)元素的变量(函数)时.就产生了闭包.
+ 闭包的到底是什么?
1. 闭包是嵌套的内部函数.(绝大多数人的理解)
2. 包含被引用变量(函数)的对象(极少数人)
3. 闭包是嵌套的内部函数.包含被引用变量(函数)的对象
+ 产生闭包的条件?
1. 函数嵌套.
2. 内部函数引用了外部函数的数据(变量/函数)
3. 执行函数定义就会产生闭包(不用调用内部函数)但是要调用外部函数,不然内部函数无法定义  执行函数定义只是定义了函数.本质上只是创建了一个函数对象.


>闭包的作用
1. 使用函数内部的变量在函数执行完后,仍然存活在内存中.(延长了局部变量的生命周期)
2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)

> 闭包一直存在没有消失的根本原因?
+ 内部函数的执行体若引用外部函数的局部变量，并且return此变量，那么执行内部函数后，此局部变量不会被销毁。
问题:
1. 函数执行后,函数内部声明的局部变量是否存在?
+ 一般不存在.存在于闭包的变量才可能存在.
+ 如果不创建一个新的引用变量.直接引用外部函数.等函数体执行完以后.闭包将会变成垃圾变量.被释放;

1. 在函数外部能直接访问到函数内部的局部变量吗?
+ 不能,但是通过闭包的技术.可以在外部操作它

>闭包的生命周期
+ 产生:在嵌套内部函数定义执行完就产生了(不是在调用的时候) 函数定义执行只是创建了函数对象
+ 闭包产生,(函数提升,内部函数对象已经创建了)
+ 死亡:在嵌套的内部函数对象称为垃圾对象的时候 包含闭包的函数对象成为了垃圾对象
